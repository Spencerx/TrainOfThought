<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg id="svg" viewBox="-100 -100 1200 600" xmlns="http://www.w3.org/2000/svg" version="1.1" onload="init()">
<!--Alternative
>>>> Screen directs manual actions, SPACE through DOMelements to make visible (including bgColored ones to overlap previous)
>>>> For a possible next version of the video, hide the guidance of where to hit the screen.-->
<style type="text/css">
text{
    text-anchor:middle;
    dominant-baseline:middle;
}
.node{    font-weight:bold;}
.edge{
    text-decoration:italic;
    stroke:lightgrey;
    fill:lightgrey;
}
line{    stroke:red;}
</style>
<script type="text/javascript"><![CDATA[
    var svg, point, canvas, nodes, edges;
	function createE(tagName){ return document.createElementNS("http://www.w3.org/2000/svg",tagName); }
	var moveXsample, moveYsample, moveXrt, moveYrt;
	function resetSampling(){
		moveXsample=-1;
		moveYsample=-2;
		moveXrt=-3;
		moveYrt=-4;
	}
	function stalled(){ return (moveXsample===moveXrt)&&(moveYsample===moveYrt); }
	const no=0, a=1, to=2, b=3;
	var phase=no, hotTe=null, typingTe=null, lastEvt=null;
	const fileNames=["","StartScratch.mp3","pewpew.mp3","LetGo.mp3"];
	const audio=[null,new Audio(fileNames[a]),new Audio(fileNames[to]),new Audio(fileNames[b])];
	const heard=["","scratch","pew","ploop"];
	var count=0;
	var TP=[]; //triple
	function resetTP(){
		TP[no]=null;
		TP[a]=null;
		TP[to]=null;
		TP[b]=null;
	}
    function KBoverride(evt){
		if (hotTe!==null){
			typingTe=hotTe;
			typingTe.textContent="";
			hotTe=null;
		}
		typingTe.textContent=typingTe.textContent+evt.key;
    }
    function pickFound(Te,log){ // ToDo: on tspan? ToDo: shuffle nodes around?
        console.log("picked one from list of found "+log); // ToDo:realiseer
		hotTe=Te; // TODO: only when clicking 1st in list
    } // === CREATE ELEMENTS ========================================
    function createNode(evt){
        var N;
        point.x = evt.clientX;
        point.y = evt.clientY;
        point = point.matrixTransform(svg.getScreenCTM().inverse());
        N=createE("text");
        N.setAttribute("class","node");
        N.setAttribute("x", Math.round(point.x));
        N.setAttribute("y", Math.round(point.y));
        N.setAttribute("onmousedown", "nodeDown(evt)");
        N.setAttribute("onmouseup",   "nodeUp(evt)");
        N.setAttribute("onmouseenter","nodeIn(evt)");
        N.setAttribute("onmouseout",  "nodeOut(evt)");
        N.textContent="...";
        return N;
    }
    function createEdge(evt){
        var Le,Te,Ge;
        point.x = evt.clientX;
        point.y = evt.clientY;
        point = point.matrixTransform(svg.getScreenCTM().inverse());
        Le=createE("line");
        Le.setAttribute("x1",Math.round(point.x));
        Le.setAttribute("y1",Math.round(point.y));
        Le.setAttribute("marker-end","url(#arrow)");
        Te=createE("text");
        Te.setAttribute("class","edge");
        Te.setAttribute("onmouseup","edgeUp(evt)");
        Te.setAttribute("onmousedown","edgeDown(evt)");
        Te.textContent="...";
        Ge=createE("g");
        Ge.appendChild(Le);
        Ge.appendChild(Te);
        return Ge;
    } // === UPDATE ELEMENTS ======================
	function setContent(elm,str){
		var Te;
		if (elm.nodeName.toLowerCase()==="text") Te=elm;
		else Te=elm.getElementsByTagName("text")[0];
		Te.textContent=str; // TODO: reset found list
		hotTe=Te; // TODO: start searching and add below
	}
	function textUpdateLater(i){
		if(i!==no) setTimeout(setContent,700,TP[i],(count++)+heard[i]); // TODO: have more realistic faked hearing
	}
	function listen(next){
		if (phase===no) resetTP();
		else textUpdateLater(phase);
		phase=next;
		if (phase!==no) audio[phase].play();  // TODO: have more realistic faked audio
	}
    function updateEdge(evt){
		var Le;
        point.x = evt.clientX;
        point.y = evt.clientY;
        point = point.matrixTransform(svg.getScreenCTM().inverse());
		x2=Math.round(point.x);
		y2=Math.round(point.y);
		Le=TP[to].getElementsByTagName("line")[0];
		Te=TP[to].getElementsByTagName("text")[0];
		x1=Le.getAttribute("x1");
		y1=Le.getAttribute("y1");
        Le.setAttribute("x2",x2);
        Le.setAttribute("y2",y2);
        Te.setAttribute("x",Math.round((parseInt(x1)+x2)/2));
        Te.setAttribute("y",Math.round((parseInt(y1)+y2)/2));
    } // ====EVENT LISTENERS ======================
    function canvasDown(evt) {evt.preventDefault();
        listen(a);
        TP[a]=createNode(evt);
        nodes.appendChild(TP[a]);
    evt.stopPropagation();}
	
    function nodeDown(evt){evt.preventDefault();
        TP[a]=evt.target;
    evt.stopPropagation();}
	
    function edgeDown(evt){evt.preventDefault();
    evt.stopPropagation();}
	
    function nodeUp(evt){evt.preventDefault();
        if ((evt.target===TP[a])&&(phase===no)) pickFound(evt.target,"nodes");
		else listen(no);
    evt.stopPropagation();}
	
    function nodeOut(evt){evt.preventDefault();
        if (evt.buttons===1){
			if(evt.target===TP[a]){
				listen(to);
				TP[to]=createEdge(evt);
				edges.append(TP[to]);
			}
			if(evt.target===TP[b]) listen(no);
        }
    evt.stopPropagation();}
	
    function nodeIn(evt){ evt.preventDefault(); // newA=noOp newB=listen(b) TP[b]=oldB
		var node=evt.target;
        if ((evt.buttons===1)&&(evt.target!==TP[a])){
			if (phase!==b){
				TP[b]=node;
				listen(no);
			}
        }
    evt.stopPropagation();}
	
/*1-2--3-0  crA+Ta+La  Ta     la+++++++cr2*T2+L2 arrow *+l2+crB+Tb+Lb Tb       lb
==========================================================================================================
0-A------0 (canvasDown--------AnodeUp)
0-a-TO-b-0             AnDown----(A.nodeOut#####-~mv~~----------------BnodeIn)               - BnUp / nOut-cUp
0-A-TO-b-0 (canvasDown--------AnodeOut##########-~mv~~----------------BnodeIn)               - BnUp / nOut-cUp
0-a-TO-B-0             AnDown----(A.nodeOut#####-~mv~~---canvasStop##----------(BnUp/BnOut)) -   0 / cUp
0-A-TO-B-0 (canvasDown--------AnodeOut##########-~mv~~---canvasStop##----------(BnUp/BnOut)) -   0 / cUp
==========================================================================================================
pickF_node             AnDown AnodeUp
pickF_edge 2.edgeDown                                     edgeUp */

	function sampleMouseOver(){
		if ((phase===to)&&(stalled())){
			TP[b]=createNode(lastEvt);
			nodes.appendChild(TP[b]);
			listen(b);
			resetSampling();
		}else{
			moveXsample=moveXrt;
			moveYsample=moveYrt;
		}
	}	
    function canvasMoveStop(evt){evt.preventDefault();
		if (phase===to){
			updateEdge(evt);
			moveXrt=evt.clientX;
			moveYrt=evt.clientY;
			lastEvt=evt;
		}
	evt.stopPropagation();}
	
	function canvasUp(evt){evt.preventDefault();
		if (phase===to){
			TP[b]=createNode(evt);
			nodes.appendChild(TP[b]);
		}
		listen(no);
	evt.stopPropagation();}
	
	function edgeUp(evt){evt.preventDefault();
        hotTe=evt.target;
        pickFound(evt.target,"edges");
    evt.stopPropagation();}
// ########  INIT  #######################################
    function EbyId(id){ return document.getElementById(id); }
    function init(evt){
        svg   =EbyId("svg");
        canvas=EbyId("canvas");
        nodes =EbyId("nodes");
        edges =EbyId("edges");
        point = svg.createSVGPoint();
		window.addEventListener("keypress", function (evt){ KBoverride(evt); })
		resetTP();
		resetSampling();
		setInterval(sampleMouseOver,800); // TODO: stalled for anything between 1 and 2 times 800
    }]]></script>
<defs>
    <marker
      id="arrow"
      viewBox="0 0 10 10"
      refX="10"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
      stroke="red" fill="red">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker><!-- &#x2022; -->
</defs>
<g id="canvas" onmousedown="canvasDown(evt)"
			   onmouseup  ="canvasUp(evt)"
               onmousemove="canvasMoveStop(evt)">
  <rect width="1200" height="600" fill="ivory" stroke="blue"/>
  <g id="edges"></g>
  <g id="nodes"></g>
</g><!-- 
- found in DBs ~2s,4s,etc after that, but showing "..." immediately, possibly
  (schedule DECIDING to add or not, as one can decide before searching finished)
- Decide on audio and text to cue, based on counting draw calls
- call the events slightly Y-shifted (otherwise they're firing hidden behind your fingers
? make a RDF data format?
Pre-print the result?

Voorbij deze mockup:
Hoe doen we de shuffle van nodes? Misschien van modus switchen door in een hoekje van het scherm te clicken?
Hoe wissen we nodes? Hoe wissen edges?
Hoe kopiÃ«ren we edgeType? Hoe reconnecten we edges? Slepen vanaf begin/midden/eind edge? Hoe vertakken we edges?
 --></svg>